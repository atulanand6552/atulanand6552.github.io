<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JSON Formatter & Validator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --danger:#f87171; --ok:#34d399; --border:#1f2937; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{margin:0; background:var(--bg); color:var(--text); font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";}
    header{padding:16px 20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg, #0b1220 0%, #0f172a 100%)}
    h1{margin:0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px}
    .wrap{display:flex; gap:12px; padding:12px; height:calc(100vh - 70px)}
    .col{display:flex; flex-direction:column; gap:8px; flex:1; min-width:0}
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:10px; display:flex; flex-direction:column; min-height:0}
    .panel h2{margin:0; padding:10px 12px; border-bottom:1px solid var(--border); font-size:13px; color:var(--muted)}
    .toolbar{display:flex; flex-wrap:wrap; gap:8px; padding:10px; border-bottom:1px solid var(--border)}
    button,.btn{
      background:#0b2530; color:#d1faff; border:1px solid #133b46; padding:8px 10px; font-size:12px; border-radius:8px; cursor:pointer;
    }
    button:hover{border-color:#1f5766}
    .btn-danger{background:#2a1111; color:#ffe8e8; border-color:#5e1d1d}
    .btn-ok{background:#0f2a20; color:#d7ffef; border-color:#1c4d3a}
    .btn-ghost{background:transparent; color:var(--muted); border-color:var(--border)}
    .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .grow{flex:1}
    textarea, pre, input[type="text"]{
      width:100%; min-height:200px; flex:1; resize:none; border:0; outline:none; background:transparent; color:var(--text); font:13px/1.5 var(--mono);
    }
    .editor{padding:10px 12px; overflow:auto}
    .status{padding:8px 12px; font-size:12px; border-top:1px solid var(--border)}
    .status.ok{color:var(--ok)}
    .status.err{color:var(--danger)}
    .split{display:flex; gap:8px; flex:1; min-height:0}
    .badge{font-size:11px; color:#8bbae1; border:1px solid #24435f; padding:2px 6px; border-radius:999px}
    .search{display:flex; gap:8px; align-items:center}
    .search input{background:#0b1220; border:1px solid var(--border); border-radius:8px; padding:8px 10px; color:var(--text); font-size:12px}
    .footer{padding:8px 12px; font-size:11px; color:var(--muted); border-top:1px solid var(--border)}
    .kv{color:#60a5fa}
    .str{color:#f472b6}
    .num{color:#f59e0b}
    .bool{color:#34d399}
    .null{color:#a78bfa}
    .hl{background:rgba(34,211,238,.12)}
    .tree{font:13px/1.5 var(--mono); padding:10px 12px; overflow:auto}
    details>summary{cursor:pointer}
    .hidden{display:none}
    @media (max-width: 900px){ .wrap{flex-direction:column; height:auto} }
  </style>
</head>
<body>
  <header>
    <h1>JSON Formatter & Validator <span class="badge">Local-first</span></h1>
    <div class="sub">Beautify, minify, validate, sort keys, search, and explore as tree â€” entirely in the browser.</div>
  </header>

  <div class="wrap">
    <!-- Input Column -->
    <section class="col">
      <div class="panel">
        <h2>Input</h2>
        <div class="toolbar">
          <div class="row">
            <button id="btnBeautify" class="btn-ok">Beautify</button>
            <button id="btnMinify">Minify</button>
            <button id="btnValidate" class="btn-ghost">Validate</button>
            <button id="btnSort">Sort Keys</button>
            <button id="btnClear" class="btn-danger">Clear</button>
          </div>
          <div class="row">
            <label class="btn-ghost">
              <input id="file" type="file" accept=".json,application/json" hidden />
              Load File
            </label>
            <button id="btnSample" class="btn-ghost">Load Sample</button>
            <button id="btnPaste" class="btn-ghost">Paste</button>
          </div>
          <div class="row grow search">
            <input id="search" class="grow" type="text" placeholder="Search (regex supported)" />
            <button id="btnFindNext" class="btn-ghost">Find</button>
          </div>
        </div>
        <div class="editor">
          <textarea id="input" placeholder='Paste JSON here or drop a .json file'></textarea>
        </div>
        <div id="status" class="status">Ready</div>
      </div>
    </section>

    <!-- Output Column -->
    <section class="col">
      <div class="panel">
        <h2>Output</h2>
        <div class="toolbar">
          <div class="row">
            <button id="btnCopy">Copy</button>
            <button id="btnDownload">Download</button>
            <button id="btnToggleView" class="btn-ghost">Tree View</button>
            <button id="btnCollapse" class="btn-ghost">Collapse</button>
            <button id="btnExpand" class="btn-ghost">Expand</button>
          </div>
        </div>
        <div id="outText" class="editor"><pre id="output" aria-label="Formatted JSON"></pre></div>
        <div id="outTree" class="tree hidden"></div>
        <div class="footer">Clipboard uses the modern async API with fallbacks. All processing is client-side.</div>
      </div>
    </section>
  </div>

  <script>
    // Utilities
    const $ = (sel) => document.querySelector(sel);
    const inputEl = $("#input");
    const outputEl = $("#output");
    const statusEl = $("#status");
    const outTextWrap = $("#outText");
    const outTreeWrap = $("#outTree");
    let lastSearch = null;

    function setStatus(msg, ok=true){
      statusEl.textContent = msg;
      statusEl.className = "status " + (ok ? "ok" : "err");
    }

    function tryParse(text){
      try{
        return { ok:true, data: JSON.parse(text) };
      }catch(e){
        return { ok:false, error: e.message };
      }
    }

    function stableSortKeys(value){
      if (Array.isArray(value)) return value.map(stableSortKeys);
      if (value && typeof value === "object"){
        const keys = Object.keys(value).sort((a,b)=> a.localeCompare(b));
        const out = {};
        for (const k of keys) out[k] = stableSortKeys(value[k]);
        return out;
      }
      return value;
    }

    function syntaxHighlight(jsonString){
      // Basic, fast highlighter for JSON strings
      return jsonString
        .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
        .replace(/(\"(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\\"])*\"\\s*:\\s*)/g, '<span class="kv">$1</span>')
        .replace(/(\"(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\\"])*\")/g, '<span class="str">$1</span>')
        .replace(/\b(-?\d+(\.\d+)?([eE][+\-]?\d+)?)\b/g, '<span class="num">$1</span>')
        .replace(/\b(true|false)\b/g, '<span class="bool">$1</span>')
        .replace(/\b(null)\b/g, '<span class="null">$1</span>');
    }

    function renderText(json, spacing=2){
      const str = JSON.stringify(json, null, spacing);
      outputEl.innerHTML = syntaxHighlight(str);
    }

    function node(label, children){
      const details = document.createElement("details");
      const summary = document.createElement("summary");
      summary.textContent = label;
      details.appendChild(summary);
      if (children && children.length){
        for (const c of children) details.appendChild(c);
      }
      return details;
    }

    function leaf(text){
      const pre = document.createElement("pre");
      pre.textContent = text;
      return pre;
    }

    function buildTree(key, value){
      if (Array.isArray(value)){
        const kids = value.map((v,i)=> buildTree(`[${i}]`, v));
        return node(`${key}: Array(${value.length})`, kids);
      }
      if (value && typeof value === "object"){
        const keys = Object.keys(value);
        const kids = keys.map(k=> buildTree(k, value[k]));
        return node(`${key}: Object(${keys.length})`, kids);
      }
      return leaf(`${key}: ${JSON.stringify(value)}`);
    }

    function renderTree(json){
      outTreeWrap.innerHTML = "";
      const root = buildTree("root", json);
      root.open = true;
      outTreeWrap.appendChild(root);
    }

    function collapseAll(open){
      outTreeWrap.querySelectorAll("details").forEach(d => d.open = open);
    }

    async function copyToClipboard(text){
      // Modern Clipboard API with fallback per current best practice
      try{
        await navigator.clipboard.writeText(text);
        setStatus("Copied to clipboard", true);
      }catch(err){
        // fallback for older contexts
        const ta = document.createElement("textarea");
        ta.value = text; document.body.appendChild(ta);
        ta.select(); ta.setSelectionRange(0, 999999);
        try{
          document.execCommand("copy");
          setStatus("Copied to clipboard (fallback)", true);
        }catch(e){
          setStatus("Copy failed: " + e.message, false);
        }finally{
          document.body.removeChild(ta);
        }
      }
    }

    function downloadText(filename, text){
      const blob = new Blob([text], {type:"application/json;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }

    function beautify(){
      const raw = inputEl.value.trim();
      if (!raw){ outputEl.textContent = ""; setStatus("Nothing to format", true); return; }
      const parsed = tryParse(raw);
      if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
      renderText(parsed.data, 2);
      setStatus("Formatted (2 spaces)", true);
      if (!outTreeWrap.classList.contains("hidden")) renderTree(parsed.data);
    }

    function minify(){
      const raw = inputEl.value.trim();
      if (!raw){ outputEl.textContent = ""; setStatus("Nothing to minify", true); return; }
      const parsed = tryParse(raw);
      if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
      const str = JSON.stringify(parsed.data);
      outputEl.textContent = str;
      setStatus("Minified", true);
      if (!outTreeWrap.classList.contains("hidden")) renderTree(parsed.data);
    }

    function validate(){
      const raw = inputEl.value.trim();
      if (!raw){ setStatus("No input", false); return; }
      const parsed = tryParse(raw);
      if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
      setStatus("Valid JSON", true);
    }

    function sortKeys(){
      const raw = inputEl.value.trim();
      if (!raw){ setStatus("No input", false); return; }
      const parsed = tryParse(raw);
      if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
      const sorted = stableSortKeys(parsed.data);
      renderText(sorted, 2);
      setStatus("Keys sorted (asc)", true);
      if (!outTreeWrap.classList.contains("hidden")) renderTree(sorted);
    }

    function toggleView(){
      const isTreeVisible = !outTreeWrap.classList.contains("hidden");
      if (isTreeVisible){
        outTreeWrap.classList.add("hidden");
        outTextWrap.classList.remove("hidden");
        $("#btnToggleView").textContent = "Tree View";
      }else{
        // generate tree from currently rendered JSON if possible
        let text = outputEl.textContent.trim();
        if (!text){
          const parsed = tryParse(inputEl.value.trim());
          if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
          renderText(parsed.data, 2);
          text = JSON.stringify(parsed.data, null, 2);
        }
        try{
          const data = JSON.parse(outputEl.textContent);
          renderTree(data);
        }catch{
          // if syntax-highlighted, reconstruct from input
          const parsed = tryParse(inputEl.value.trim());
          if (!parsed.ok){ setStatus("Invalid JSON: " + parsed.error, false); return; }
          renderTree(parsed.data);
        }
        outTextWrap.classList.add("hidden");
        outTreeWrap.classList.remove("hidden");
        $("#btnToggleView").textContent = "Text View";
      }
    }

    function clearAll(){
      inputEl.value = "";
      outputEl.textContent = "";
      outTreeWrap.innerHTML = "";
      setStatus("Cleared", true);
    }

    function loadSample(){
      const sample = {
        productId: "SKU-12345",
        name: "Noise Cancelling Headphones",
        price: 149.99,
        currency: "USD",
        inStock: true,
        tags: ["audio","headphones","wireless"],
        specs: { batteryHours: 32, codecs: ["AAC","LDAC"], weightGrams: 240 },
        variants: [
          { color:"Black", sku:"SKU-12345-BLK" },
          { color:"Silver", sku:"SKU-12345-SLV" }
        ],
        updatedAt: new Date().toISOString()
      };
      inputEl.value = JSON.stringify(sample, null, 2);
      renderText(sample, 2);
      setStatus("Loaded sample JSON", true);
    }

    function currentOutputString(){
      // Prefer the text content to avoid HTML spans from syntax highlighting
      return outputEl.textContent;
    }

    function findNext(){
      const query = $("#search").value;
      if (!query){ setStatus("Enter search text", false); return; }
      const text = currentOutputString();
      if (!text){ setStatus("No output to search", false); return; }
      let re;
      try{ re = new RegExp(query, "g"); }
      catch(e){ setStatus("Invalid regex: " + e.message, false); return; }
      if (!lastSearch || lastSearch.query !== query){
        lastSearch = { query, matches: [...text.matchAll(re)], idx: -1 };
      }
      if (!lastSearch.matches.length){ setStatus("No matches", false); return; }
      lastSearch.idx = (lastSearch.idx + 1) % lastSearch.matches.length;
      const m = lastSearch.matches[lastSearch.idx];
      // Highlight by recreating pre HTML with spans around the match
      const before = text.slice(0, m.index);
      const hit = text.slice(m.index, m.index + m.length);
      const after = text.slice(m.index + m.length);
      outputEl.innerHTML = syntaxHighlight(before) + '<span class="hl">' + hit.replace(/</g,"&lt;") + '</span>' + syntaxHighlight(after);
      setStatus(`Match ${lastSearch.idx+1}/${lastSearch.matches.length}`, true);
    }

    // Events
    $("#btnBeautify").addEventListener("click", beautify);
    $("#btnMinify").addEventListener("click", minify);
    $("#btnValidate").addEventListener("click", validate);
    $("#btnSort").addEventListener("click", sortKeys);
    $("#btnClear").addEventListener("click", clearAll);
    $("#btnSample").addEventListener("click", loadSample);
    $("#btnFindNext").addEventListener("click", findNext);

    $("#btnToggleView").addEventListener("click", toggleView);
    $("#btnCollapse").addEventListener("click", ()=> collapseAll(false));
    $("#btnExpand").addEventListener("click", ()=> collapseAll(true));

    $("#btnCopy").addEventListener("click", ()=> copyToClipboard(currentOutputString()));
    $("#btnDownload").addEventListener("click", ()=>{
      const text = currentOutputString();
      if (!text){ setStatus("Nothing to download", false); return; }
      downloadText("formatted.json", text);
      setStatus("Downloaded formatted.json", true);
    });

    $("#btnPaste").addEventListener("click", async ()=>{
      try{
        const text = await navigator.clipboard.readText();
        inputEl.value = text;
        setStatus("Pasted from clipboard", true);
      }catch(e){
        setStatus("Paste failed (permissions or insecure context)", false);
      }
    });

    $("#file").addEventListener("change", async (e)=>{
      const f = e.target.files;
      if (!f) return;
      const text = await f.text();
      inputEl.value = text;
      setStatus("File loaded: " + f.name, true);
    });

    // Drag & Drop support
    document.addEventListener("dragover", (e)=>{ e.preventDefault(); });
    document.addEventListener("drop", async (e)=>{
      e.preventDefault();
      const f = e.dataTransfer?.files?.;
      if (f){
        const text = await f.text();
        inputEl.value = text;
        setStatus("File dropped: " + f.name, true);
      }
    });

    // Live validation hint for large inputs
    let validateTimer;
    inputEl.addEventListener("input", ()=>{
      clearTimeout(validateTimer);
      validateTimer = setTimeout(()=>{
        const val = inputEl.value.trim();
        if (!val){ setStatus("Ready", true); return; }
        const {ok, error} = tryParse(val);
        setStatus(ok ? "Looks valid so far" : ("Invalid: " + error), ok);
      }, 400);
    });

    // Initial sample
    loadSample();
  </script>
</body>
</html>
